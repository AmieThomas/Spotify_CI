---
title: "Untitled"
output: html_document
date: "2024-04-09"
---

```{r}
# Assuming 'final_df' is your final dataframe
# Assuming 'cluster_similarity' and 'not_skipped' are binary variables in 'final_df'
 
# Count the number of 1s and 0s in 'cluster_similarity'
cluster_similarity_count <- table(final$cluster_similarity)
print(cluster_similarity_count)
 
# Count the number of 1s and 0s in 'not_skipped'
not_skipped_count <- table(final$not_skipped)
print(not_skipped_count)
 
 
ones_match <- sum(final$cluster_similarity == 0 & final$not_skipped == 0 )
print(ones_match)
 
zeros_match <- sum(final$cluster_similarity == 0 & final$not_skipped == 0)
print(zeros_match)

```

```{r}
#Risk ratio and cornfield analysis of the dataf dataset
#binary treatment variable- if the current song is different than the previous song or not
#would we have to see if the previous song wasn't skipped and just keep these cases- we want cases where the listner liked the first song-didnt skip and skipped because the vibe was different(he didnt like it) in the second song
#I am doing this for now. We can change the code later
 
#First we divide the dataset into nuisance and effect
 
nuisance_indices <- sample(nrow(data), size = nrow(data) / 2)
    train <- final[nuisance_indices, ]
    test <- final[-nuisance_indices, ]
 
    # Subset the data frame based on the condition
    trainT <- train[train$not_skipped == 0, ]
    trainC <- train[train$not_skipped == 1, ]
 
    # Fit regression models
    fit1 <- lm(not_skipped ~ . -not_skipped  - a, data = trainC, family= "binomial")
    fit2 <- lm(not_skipped ~ . -not_skipped - a, data = trainT, family= "binomial")
 
    # Predictions
    u0 <- predict(fit1, newdata = test)
    u1 <- predict(fit2, newdata = test)
 
```
 
```{r}
#count u0- 1s and 0s
#count u1- 1s and 0s
#RR= [u1(1s)/total number of u1)]/ [u0(1s)/total number of u0s]
```
 
 
```{r}
# Assuming u0 and u1 are vectors of predictions from fit1 and fit2 respectively
 
# Count 1s and 0s in u0 and u1
u0_1s <- sum(u0 == 1)
u0_0s <- sum(u0 == 0)
 
u1_1s <- sum(u1 == 1)
u1_0s <- sum(u1 == 0)
 
# Calculate Relative Risk
RR <- (u1_1s / length(u1)) / (u0_1s / length(u0))
 
```
 
```{r}
# Assuming 'final_df' is your final dataframe
# Assuming 'cluster_similarity' and 'not_skipped' are binary variables in 'final_df'
 
# Count the number of 1s and 0s in 'cluster_similarity'
cluster_similarity_count <- table(final$cluster_similarity)
print(cluster_similarity_count)
 
# Count the number of 1s and 0s in 'not_skipped'
not_skipped_count <- table(final$not_skipped)
print(not_skipped_count)
 
 
ones_match <- sum(final$cluster_similarity == 0 & final$not_skipped == 0 )
print(ones_match)
 
zeros_match <- sum(final$cluster_similarity == 0 & final$not_skipped == 0)
print(zeros_match)
 
```

```{r}
#Risk ratio and cornfield analysis of the dataf dataset
#binary treatment variable- if the current song is different than the previous song or not
#would we have to see if the previous song wasn't skipped and just keep these cases- we want cases where the listner liked the first song-didnt skip and skipped because the vibe was different(he didnt like it) in the second song
#I am doing this for now. We can change the code later

#First we divide the dataset into nuisance and effect
# Remove the "session_id" and "track_id" columns from the final dataset

set.seed(123)

# Divide the data into training and testing sets (50/50 split)
n <- nrow(final)
train_index <- sample(1:n, n/2)
train <- final[train_index, ]
test <- final[-train_index, ]

# Subset the data frame based on the condition
trainT <- train[train$cluster_similarity == 0, ]
trainC <- train[train$cluster_similarity == 1, ]

# Fit regression models
model1 <- glm( not_skipped~. - cluster_similarity -not_skipped ,data= trainT, family= binomial)
model0 <- glm( not_skipped~. - cluster_similarity -not_skipped , data= trainC, family= binomial)

test <- droplevels(test)

# Predictions
u0 <- predict(model0, newdata = test)
u1 <- predict(model1, newdata = test)


# Assuming u0 and u1 are the predicted probabilities from logistic regression models
threshold <- 0.5

# Convert predicted probabilities to binary predictions
u0 <- ifelse(u0 > threshold, 1, 0)
u1 <- ifelse(u1 > threshold, 1, 0)


```

```{r}
#count u0- 1s and 0s
#count u1- 1s and 0s
#RR= [u1(1s)/total number of u1)]/ [u0(1s)/total number of u0s]
```


```{r}
# Assuming u0 and u1 are vectors of predictions from fit1 and fit2 respectively

# Count 1s and 0s in u0 and u1
u0_1s <- sum(u0 == 1)
u0_0s <- sum(u0 == 0)

u1_1s <- sum(u1 == 1)
u1_0s <- sum(u1 == 0)

# Calculate Relative Risk
RRm <- (u1_1s / sum(u1)) / (u0_1s / sum(u0))

```

```{r}
# Assuming 'final_df' is your final dataframe
# Assuming 'cluster_similarity' and 'not_skipped' are binary variables in 'final_df'

# Count the number of 1s and 0s in 'cluster_similarity'
cluster_similarity_count <- table(final$cluster_similarity)
print(cluster_similarity_count)

# Count the number of 1s and 0s in 'not_skipped'
not_skipped_count <- table(final$not_skipped)
print(not_skipped_count)

A0<- sum(final$cluster_similarity==0, na.rm = TRUE)
A1<- sum(final$cluster_similarity==1, na.rm = TRUE)
Y1 <- sum(final$cluster_similarity == 1 & final$not_skipped == 1 )

Y0 <- sum(final$cluster_similarity == 0 & final$not_skipped == 1, na.rm = TRUE)

RR<- (Y1/A1)/(Y0/A0)

#things we can try- making all new sessions NAs
#altering the code so that only those rows are kept for which the first song wasn't skipped but the second was.
```

```{r}
###DONT RUN
# Assuming u0 and u1 are the predicted probabilities from logistic regression models
threshold <- 0.5

# Convert predicted probabilities to binary predictions
u0 <- ifelse(u0 > threshold, 1, 0)
u1 <- ifelse(u1 > threshold, 1, 0)

# Check against the testing set
# Assuming starbucks_test$actual_outcome contains the actual outcomes in the testing set
accuracy_u0 <- mean(binary_predictions_u0 == test$not_skipped)
accuracy_u1 <- mean(binary_predictions_u1 == test$not_skipped)

# Print accuracies
cat("Accuracy for model 0:", accuracy_u0, "\n")
cat("Accuracy for model 1:", accuracy_u1, "\n")

```

